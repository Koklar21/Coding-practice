# Aegis42_watchtower.py
from __future__ import annotations
import hashlib
import hmac
import json
import logging
import threading
import time
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Optional, Tuple

# optional: lightweight sklearn import for batch anomaly detector upgrade
try:
    from sklearn.ensemble import IsolationForest  # type: ignore
    SKLEARN_AVAILABLE = True
except Exception:
    SKLEARN_AVAILABLE = False

logger = logging.getLogger("Aegis42Watchtower")
if not logger.handlers:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s | AEGIS-42 | %(levelname)s | %(message)s")

# ---------------------------
# CPA chaining helper (tamper-evident)
# ---------------------------
def hash_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

@dataclass
class CPAEntry:
    timestamp: str
    payload: Dict[str, Any]
    prev_hash: Optional[str]
    entry_hash: str

def cpa_chain_entry(payload: Dict[str, Any], prev_hash: Optional[str]) -> CPAEntry:
    payload_json = json.dumps(payload, sort_keys=True, separators=(",", ":"), default=str)
    ts = datetime.now(timezone.utc).isoformat()
    raw = f"{ts}|{payload_json}|{prev_hash}".encode("utf-8")
    entry_hash = hash_bytes(raw)
    return CPAEntry(timestamp=ts, payload=payload, prev_hash=prev_hash, entry_hash=entry_hash)

# ---------------------------
# Watchtower: ingest, store CPA chain, basic rules
# ---------------------------
class Watchtower:
    def __init__(self, signing_key: bytes):
        """
        signing_key: HMAC key for local attestation of CPA roots.
        In production this should be HSM-backed; here it's a minimal placeholder.
        """
        self.signing_key = signing_key
        self.chain: List[CPAEntry] = []
        self.index_by_source: Dict[str, List[str]] = {}
        self.lock = threading.RLock()
        self.rules: List[Callable[[CPAEntry], Optional[Dict[str, Any]]]] = []
        self.alert_handlers: List[Callable[[Dict[str, Any]], None]] = []
        self.av_hook: Optional[AVHook] = None

    def attest_root(self) -> Dict[str, str]:
        """Return signed root hash for external anchoring."""
        with self.lock:
            root = self.chain[-1].entry_hash if self.chain else ""
            sig = hmac.new(self.signing_key, root.encode("utf-8"), hashlib.sha256).hexdigest()
            return {"root": root, "sig": sig, "timestamp": datetime.now(timezone.utc).isoformat()}

    def ingest(self, payload: Dict[str, Any]) -> CPAEntry:
        """Ingest a structured payload, append to CPA chain, evaluate rules."""
        with self.lock:
            prev = self.chain[-1].entry_hash if self.chain else None
            entry = cpa_chain_entry(payload, prev)
            self.chain.append(entry)
            src = payload.get("source")
            if src:
                self.index_by_source.setdefault(src, []).append(entry.entry_hash)
            logger.info(f"Watchtower ingest: src={src} type={payload.get('type')}")
        # evaluate rules outside lock to avoid deadlocks
        for rule in self.rules:
            try:
                alert = rule(entry)
                if alert:
                    self._handle_alert(alert)
            except Exception as e:
                logger.exception("Rule evaluation error: %s", e)
        return entry

    def register_rule(self, rule_fn: Callable[[CPAEntry], Optional[Dict[str, Any]]]) -> None:
        """Register a rule that returns an alert dict or None."""
        self.rules.append(rule_fn)

    def register_alert_handler(self, handler_fn: Callable[[Dict[str, Any]], None]) -> None:
        self.alert_handlers.append(handler_fn)

    def _handle_alert(self, alert: Dict[str, Any]) -> None:
        logger.warning(f"ALERT: {alert}")
        for h in self.alert_handlers:
            try:
                h(alert)
            except Exception:
                logger.exception("Alert handler failed")

    def attach_av_hook(self, av_hook: "AVHook") -> None:
        self.av_hook = av_hook
        logger.info("AV hook attached to Watchtower.")

# ---------------------------
# AV / Threat Intel Hook interface
# ---------------------------
class AVHook:
    """
    Minimal interface for AV / threat intel providers.
    Implementers should fetch indicators, signature updates, and provide lookup methods.
    """
    def __init__(self):
        self.indicators = set()  # example: IPs, hashes, domains

    def update_from_provider(self, batch: List[str]) -> None:
        """Bulk update indicators (hashes, ips, domains)."""
        self.indicators.update(batch)

    def is_indicator(self, value: str) -> bool:
        return value in self.indicators

# ---------------------------
# Simple online learner (z-score) + optional batch IsolationForest
# ---------------------------
class OnlineAnomalyDetector:
    """
    Lightweight streaming learner:
      - Keeps running mean/variance per numeric feature and computes z-score.
      - Optionally accept batch feature vectors and use sklearn IsolationForest when available.
    """

    def __init__(self, zscore_threshold: float = 4.0):
        self.count = 0
        self.mean = 0.0
        self.M2 = 0.0
        self.zscore_threshold = zscore_threshold
        self.buffer: List[List[float]] = []
        self.if_model = None
        if SKLEARN_AVAILABLE:
            self.if_model = IsolationForest(n_estimators=64, contamination=0.01, random_state=42)

    def update_stream(self, value: float) -> Optional[Dict[str, Any]]:
        # Welford's online mean/variance
        self.count += 1
        delta = value - self.mean
        self.mean += delta / self.count
        delta2 = value - self.mean
        self.M2 += delta * delta2
        if self.count < 2:
            return None
        variance = self.M2 / (self.count - 1)
        std = variance ** 0.5 if variance > 0 else 0.0
        z = abs((value - self.mean) / std) if std > 0 else 0.0
        if z > self.zscore_threshold:
            return {"type": "anomaly", "value": value, "zscore": z, "mean": self.mean, "std": std}
        return None

    def add_batch_feature_vector(self, vec: List[float]) -> None:
        self.buffer.append(vec)
        if len(self.buffer) >= 256 and self.if_model:
            # train/update model in background thread
            try:
                self.if_model.fit(self.buffer)
                self.buffer.clear()
                logger.info("IsolationForest trained on batch.")
            except Exception:
                logger.exception("Batch training failed.")

    def predict_if_anomalous(self, vec: List[float]) -> bool:
        if self.if_model:
            pred = self.if_model.predict([vec])[0]  # returns 1 or -1
            return pred == -1
        return False

# ---------------------------
# Self-Repair Agent (safe, auditable actions)
# ---------------------------
@dataclass
class RepairAction:
    id: str
    name: str
    params: Dict[str, Any]
    timestamp: str
    status: str = "PENDING"
    actor: Optional[str] = None  # system or username who approved/sent action

class SelfRepairAgent:
    """
    Register remediation handlers, request/authorize actions, execute with audit.
    Destructive actions MUST be multi-signer in production.
    """
    def __init__(self):
        self.handlers: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] = {}
        self.action_log: List[RepairAction] = []
        self.lock = threading.RLock()

    def register_handler(self, action_name: str, fn: Callable[[Dict[str, Any]], Dict[str, Any]]) -> None:
        self.handlers[action_name] = fn
        logger.info("Repair handler registered: %s", action_name)

    def request_action(self, action_name: str, params: Dict[str, Any], actor: Optional[str] = "system") -> RepairAction:
        if action_name not in self.handlers:
            raise RuntimeError("Unknown repair action")
        ra = RepairAction(id=hashlib.sha1((action_name + str(time.time())).encode()).hexdigest(),
                          name=action_name, params=params, timestamp=datetime.now(timezone.utc).isoformat(),
                          actor=actor)
        with self.lock:
            self.action_log.append(ra)
        # Execute synchronously for now (could be queued)
        try:
            ra.status = "EXECUTING"
            ret = self.handlers[action_name](params)
            ra.status = "SUCCESS"
            logger.info("RepairAction success: %s -> %s", ra.name, ret)
        except Exception as e:
            ra.status = "FAILED"
            logger.exception("RepairAction failed: %s", e)
        return ra

# ---------------------------
# Example: tie all together
# ---------------------------
def example_setup():
    # signing key should be HSM backed in prod
    watch = Watchtower(signing_key=b"dev-temp-key-please-use-hsm")
    av = AVHook()
    # preload some indicators (in reality, sync from vendor feeds)
    av.update_from_provider(["203.0.113.15", "baddomain.example", "deadbeefhash"])
    watch.attach_av_hook(av)

    # anomaly detector
    learner = OnlineAnomalyDetector(zscore_threshold=3.5)

    # Register a basic rule: flag CPA entries with source in AV indicators or large numeric anomalies
    def rule_av_and_anomaly(entry: CPAEntry) -> Optional[Dict[str, Any]]:
        payload = entry.payload
        src = payload.get("source", "")
        if watch.av_hook and watch.av_hook.is_indicator(src):
            return {"type": "threat_intel_match", "reason": "Source in AV feed", "source": src, "entry": entry.entry_hash}
        # if payload has numeric metric 'value' we stream to learner
        val = payload.get("metrics", {}).get("value")
        if isinstance(val, (int, float)):
            a = learner.update_stream(float(val))
            if a:
                return {"type": "stat_anomaly", "details": a, "entry": entry.entry_hash}
        return None

    watch.register_rule(rule_av_and_anomaly)

    # register a simple repair agent (quarantine IP & block egress)
    repair = SelfRepairAgent()
    def quarantine_ip_handler(params: Dict[str, Any]) -> Dict[str, Any]:
        ip = params.get("ip")
        if not ip:
            raise RuntimeError("missing ip")
        # placeholder: call firewall API or orchestration system -> here we just log
        logger.info("Quarantine request applied to IP: %s (simulated)", ip)
        return {"quarantined": ip}
    repair.register_handler("quarantine_ip", quarantine_ip_handler)

    # attach alert handler to auto-request remediation for threat_intel_match
    def alert_to_repair(alert: Dict[str, Any]) -> None:
        if alert.get("type") == "threat_intel_match":
            src = alert.get("source")
            # safe default: request quarantine, actor is 'auto-system'
            repair.request_action("quarantine_ip", {"ip": src}, actor="auto-system")

    watch.register_alert_handler(alert_to_repair)

    # ingest several events
    watch.ingest({"type": "network", "source": "192.0.2.1", "metrics": {"value": 1}})
    watch.ingest({"type": "network", "source": "203.0.113.15", "metrics": {"value": 9.0}})
    watch.ingest({"type": "syslog", "source": "192.168.0.5", "metrics": {"value": 6.3}})

    print("Attestation:", watch.attest_root())
    print("Chain length:", len(watch.chain))
    return watch, learner, repair

if __name__ == "__main__":
    example_setup()