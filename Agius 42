from __future__ import annotations

import logging
from dataclasses import dataclass, field, asdict
from datetime import datetime, timezone
from enum import Enum, auto
from typing import Any, Dict, List, Tuple

# ---------------------------
# Logger setup
# ---------------------------
logger = logging.getLogger("Aegis42SecurityNode")
if not logger.handlers:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s | AEGIS-42 | %(levelname)s | %(message)s",
    )


# ---------------------------
# Enums & Exceptions
# ---------------------------
class Severity(Enum):
    LOW = auto()
    MEDIUM = auto()
    HIGH = auto()
    CRITICAL = auto()


class SecurityMode(Enum):
    NORMAL = "Normal"
    ELEVATED = "Elevated"
    LOCKDOWN = "Lockdown"


class SecurityNodeError(Exception):
    """Raised for invalid operations in the security node."""
    pass


# ---------------------------
# Data Structures
# ---------------------------
@dataclass
class EventEntry:
    timestamp: datetime
    message: str


@dataclass
class ThreatEntry:
    timestamp: datetime
    source: str
    description: str
    severity: Severity
    # Optional numeric score for later analytics
    score: int = field(default=0)


# ---------------------------
# Core Security Node
# ---------------------------
class SecurityNode:
    """
    Aegis-42 core security node.

    Tracks events, threats, firewall posture, and security mode.
    This is intended as the baseline for a larger Aegis-42/Watchtower stack.
    """

    SEVERITY_SCORES: Dict[Severity, int] = {
        Severity.LOW: 1,
        Severity.MEDIUM: 5,
        Severity.HIGH: 15,
        Severity.CRITICAL: 30,
    }

    def __init__(self, node_id: str = "aegis-42-core", max_firewall_layers: int = 42) -> None:
        self.node_id: str = node_id
        self.max_firewall_layers: int = max_firewall_layers

        self.event_log: List[EventEntry] = []
        self.threat_log: List[ThreatEntry] = []
        self.system_status: Dict[str, str] = {}

        self.firewall_layer: int = 0
        self.security_mode: SecurityMode = SecurityMode.NORMAL
        self.cumulative_threat_score: int = 0

        self._log_event("Security Node initialized.")
        self._update_system_status(
            "Firewall",
            f"Inactive (Layer {self.firewall_layer}/{self.max_firewall_layers})",
        )

    # ---------------------------
    # Internal helpers
    # ---------------------------
    @staticmethod
    def _utc_now() -> datetime:
        return datetime.now(timezone.utc)

    def _log_event(self, message: str) -> None:
        entry = EventEntry(timestamp=self._utc_now(), message=message)
        self.event_log.append(entry)
        logger.info(f"[EVENT] {message}")

    def _update_system_status(self, component: str, status: str) -> None:
        old_status = self.system_status.get(component, "Unknown")
        self.system_status[component] = status
        self._log_event(
            f"{component} status changed from '{old_status}' to '{status}'"
        )

    def _normalize_severity(self, severity: str | Severity) -> Severity:
        if isinstance(severity, Severity):
            return severity

        normalized = severity.strip().upper()
        mapping = {
            "LOW": Severity.LOW,
            "MEDIUM": Severity.MEDIUM,
            "HIGH": Severity.HIGH,
            "CRITICAL": Severity.CRITICAL,
        }
        if normalized not in mapping:
            raise SecurityNodeError(f"Invalid severity: {severity}")
        return mapping[normalized]

    def _log_threat_internal(
        self, source: str, description: str, severity: Severity
    ) -> ThreatEntry:
        score = self.SEVERITY_SCORES[severity]
        entry = ThreatEntry(
            timestamp=self._utc_now(),
            source=source,
            description=description,
            severity=severity,
            score=score,
        )
        self.threat_log.append(entry)
        self.cumulative_threat_score += score

        logger.warning(
            f"[THREAT] source={source} | severity={severity.name} | score={score} | {description}"
        )
        return entry

    def _auto_adjust_posture(self, severity: Severity) -> None:
        """
        Simple posture logic:
        - HIGH     -> at least ELEVATED
        - CRITICAL -> LOCKDOWN
        """
        if severity == Severity.CRITICAL:
            if self.security_mode != SecurityMode.LOCKDOWN:
                self.switch_security_mode(SecurityMode.LOCKDOWN)
        elif severity == Severity.HIGH:
            if self.security_mode == SecurityMode.NORMAL:
                self.switch_security_mode(SecurityMode.ELEVATED)

    # ---------------------------
    # Public API
    # ---------------------------
    def update_component_status(self, component: str, status: str) -> None:
        """Public wrapper to update system component status."""
        self._update_system_status(component, status)

    def advance_firewall(self, steps: int = 1) -> None:
        """
        Advance firewall posture by N layers.
        Raises if exceeding max_firewall_layers.
        """
        if steps <= 0:
            raise SecurityNodeError("Firewall advance steps must be positive.")

        new_layer = self.firewall_layer + steps
        if new_layer > self.max_firewall_layers:
            raise SecurityNodeError(
                f"Firewall is at maximum layer ({self.max_firewall_layers})."
            )

        self.firewall_layer = new_layer
        difficulty = round(self.firewall_layer * 3.0, 2)
        self._update_system_status(
            "Firewall",
            f"Active (Layer {self.firewall_layer}/{self.max_firewall_layers}, "
            f"Difficulty: {difficulty})",
        )

    def switch_security_mode(self, mode: SecurityMode | str) -> None:
        """Switch overall security mode with validation and logging."""

        if isinstance(mode, str):
            normalized = mode.strip().capitalize()
            mapping = {
                "Normal": SecurityMode.NORMAL,
                "Elevated": SecurityMode.ELEVATED,
                "Lockdown": SecurityMode.LOCKDOWN,
            }
            if normalized not in mapping:
                raise SecurityNodeError(f"Invalid security mode: {mode}")
            mode_enum = mapping[normalized]
        else:
            mode_enum = mode

        old_mode = self.security_mode
        self.security_mode = mode_enum
        self._log_event(f"Security mode changed from {old_mode.value} to {mode_enum.value}")

    def log_threat(self, source: str, description: str, severity: str | Severity) -> None:
        """
        Public method to log a threat and auto-adjust posture.
        """
        sev_enum = self._normalize_severity(severity)
        self._log_threat_internal(source, description, sev_enum)
        self._auto_adjust_posture(sev_enum)

    def get_summary(self) -> Dict[str, Any]:
        """High-level summary for dashboards / quick status checks."""
        return {
            "node_id": self.node_id,
            "total_events": len(self.event_log),
            "total_threats": len(self.threat_log),
            "firewall_layer": self.firewall_layer,
            "max_firewall_layers": self.max_firewall_layers,
            "security_mode": self.security_mode.value,
            "cumulative_threat_score": self.cumulative_threat_score,
            "system_components": len(self.system_status),
        }

    def get_logs(self) -> Dict[str, Any]:
        """Return logs as JSON-serializable structures."""
        return {
            "event_log": [
                {
                    "timestamp": e.timestamp.isoformat(),
                    "message": e.message,
                }
                for e in self.event_log
            ],
            "threat_log": [
                {
                    "timestamp": t.timestamp.isoformat(),
                    "source": t.source,
                    "description": t.description,
                    "severity": t.severity.name,
                    "score": t.score,
                }
                for t in self.threat_log
            ],
            "system_status": self.system_status.copy(),
        }


# ---------------------------
# Example usage / quick self-test
# ---------------------------
if __name__ == "__main__":
    node = SecurityNode()

    node.update_component_status("IDS", "Monitoring")
    node.update_component_status("SIEM", "Online")

    node.log_threat("192.168.0.5", "Port scan detected", "Medium")
    node.log_threat("203.0.113.15", "DDoS signatures identified", "Critical")

    for _ in range(5):
        node.advance_firewall()

    print("SUMMARY:")
    print(node.get_summary())

    print("\nLOG EXPORT:")
    print(node.get_logs())


# Aegis42_watchtower.py
from __future__ import annotations
import hashlib
import hmac
import json
import logging
import threading
import time
from dataclasses import dataclass, asdict, field
from datetime import datetime, timezone
from typing import Any, Callable, Dict, List, Optional, Tuple

# optional: lightweight sklearn import for batch anomaly detector upgrade
try:
    from sklearn.ensemble import IsolationForest  # type: ignore
    SKLEARN_AVAILABLE = True
except Exception:
    SKLEARN_AVAILABLE = False

logger = logging.getLogger("Aegis42Watchtower")
if not logger.handlers:
    logging.basicConfig(level=logging.INFO, format="%(asctime)s | AEGIS-42 | %(levelname)s | %(message)s")

# ---------------------------
# CPA chaining helper (tamper-evident)
# ---------------------------
def hash_bytes(b: bytes) -> str:
    return hashlib.sha256(b).hexdigest()

@dataclass
class CPAEntry:
    timestamp: str
    payload: Dict[str, Any]
    prev_hash: Optional[str]
    entry_hash: str

def cpa_chain_entry(payload: Dict[str, Any], prev_hash: Optional[str]) -> CPAEntry:
    payload_json = json.dumps(payload, sort_keys=True, separators=(",", ":"), default=str)
    ts = datetime.now(timezone.utc).isoformat()
    raw = f"{ts}|{payload_json}|{prev_hash}".encode("utf-8")
    entry_hash = hash_bytes(raw)
    return CPAEntry(timestamp=ts, payload=payload, prev_hash=prev_hash, entry_hash=entry_hash)

# ---------------------------
# Watchtower: ingest, store CPA chain, basic rules
# ---------------------------
class Watchtower:
    def __init__(self, signing_key: bytes):
        """
        signing_key: HMAC key for local attestation of CPA roots.
        In production this should be HSM-backed; here it's a minimal placeholder.
        """
        self.signing_key = signing_key
        self.chain: List[CPAEntry] = []
        self.index_by_source: Dict[str, List[str]] = {}
        self.lock = threading.RLock()
        self.rules: List[Callable[[CPAEntry], Optional[Dict[str, Any]]]] = []
        self.alert_handlers: List[Callable[[Dict[str, Any]], None]] = []
        self.av_hook: Optional[AVHook] = None

    def attest_root(self) -> Dict[str, str]:
        """Return signed root hash for external anchoring."""
        with self.lock:
            root = self.chain[-1].entry_hash if self.chain else ""
            sig = hmac.new(self.signing_key, root.encode("utf-8"), hashlib.sha256).hexdigest()
            return {"root": root, "sig": sig, "timestamp": datetime.now(timezone.utc).isoformat()}

    def ingest(self, payload: Dict[str, Any]) -> CPAEntry:
        """Ingest a structured payload, append to CPA chain, evaluate rules."""
        with self.lock:
            prev = self.chain[-1].entry_hash if self.chain else None
            entry = cpa_chain_entry(payload, prev)
            self.chain.append(entry)
            src = payload.get("source")
            if src:
                self.index_by_source.setdefault(src, []).append(entry.entry_hash)
            logger.info(f"Watchtower ingest: src={src} type={payload.get('type')}")
        # evaluate rules outside lock to avoid deadlocks
        for rule in self.rules:
            try:
                alert = rule(entry)
                if alert:
                    self._handle_alert(alert)
            except Exception as e:
                logger.exception("Rule evaluation error: %s", e)
        return entry

    def register_rule(self, rule_fn: Callable[[CPAEntry], Optional[Dict[str, Any]]]) -> None:
        """Register a rule that returns an alert dict or None."""
        self.rules.append(rule_fn)

    def register_alert_handler(self, handler_fn: Callable[[Dict[str, Any]], None]) -> None:
        self.alert_handlers.append(handler_fn)

    def _handle_alert(self, alert: Dict[str, Any]) -> None:
        logger.warning(f"ALERT: {alert}")
        for h in self.alert_handlers:
            try:
                h(alert)
            except Exception:
                logger.exception("Alert handler failed")

    def attach_av_hook(self, av_hook: "AVHook") -> None:
        self.av_hook = av_hook
        logger.info("AV hook attached to Watchtower.")

# ---------------------------
# AV / Threat Intel Hook interface
# ---------------------------
class AVHook:
    """
    Minimal interface for AV / threat intel providers.
    Implementers should fetch indicators, signature updates, and provide lookup methods.
    """
    def __init__(self):
        self.indicators = set()  # example: IPs, hashes, domains

    def update_from_provider(self, batch: List[str]) -> None:
        """Bulk update indicators (hashes, ips, domains)."""
        self.indicators.update(batch)

    def is_indicator(self, value: str) -> bool:
        return value in self.indicators

# ---------------------------
# Simple online learner (z-score) + optional batch IsolationForest
# ---------------------------
class OnlineAnomalyDetector:
    """
    Lightweight streaming learner:
      - Keeps running mean/variance per numeric feature and computes z-score.
      - Optionally accept batch feature vectors and use sklearn IsolationForest when available.
    """

    def __init__(self, zscore_threshold: float = 4.0):
        self.count = 0
        self.mean = 0.0
        self.M2 = 0.0
        self.zscore_threshold = zscore_threshold
        self.buffer: List[List[float]] = []
        self.if_model = None
        if SKLEARN_AVAILABLE:
            self.if_model = IsolationForest(n_estimators=64, contamination=0.01, random_state=42)

    def update_stream(self, value: float) -> Optional[Dict[str, Any]]:
        # Welford's online mean/variance
        self.count += 1
        delta = value - self.mean
        self.mean += delta / self.count
        delta2 = value - self.mean
        self.M2 += delta * delta2
        if self.count < 2:
            return None
        variance = self.M2 / (self.count - 1)
        std = variance ** 0.5 if variance > 0 else 0.0
        z = abs((value - self.mean) / std) if std > 0 else 0.0
        if z > self.zscore_threshold:
            return {"type": "anomaly", "value": value, "zscore": z, "mean": self.mean, "std": std}
        return None

    def add_batch_feature_vector(self, vec: List[float]) -> None:
        self.buffer.append(vec)
        if len(self.buffer) >= 256 and self.if_model:
            # train/update model in background thread
            try:
                self.if_model.fit(self.buffer)
                self.buffer.clear()
                logger.info("IsolationForest trained on batch.")
            except Exception:
                logger.exception("Batch training failed.")

    def predict_if_anomalous(self, vec: List[float]) -> bool:
        if self.if_model:
            pred = self.if_model.predict([vec])[0]  # returns 1 or -1
            return pred == -1
        return False

# ---------------------------
# Self-Repair Agent (safe, auditable actions)
# ---------------------------
@dataclass
class RepairAction:
    id: str
    name: str
    params: Dict[str, Any]
    timestamp: str
    status: str = "PENDING"
    actor: Optional[str] = None  # system or username who approved/sent action

class SelfRepairAgent:
    """
    Register remediation handlers, request/authorize actions, execute with audit.
    Destructive actions MUST be multi-signer in production.
    """
    def __init__(self):
        self.handlers: Dict[str, Callable[[Dict[str, Any]], Dict[str, Any]]] = {}
        self.action_log: List[RepairAction] = []
        self.lock = threading.RLock()

    def register_handler(self, action_name: str, fn: Callable[[Dict[str, Any]], Dict[str, Any]]) -> None:
        self.handlers[action_name] = fn
        logger.info("Repair handler registered: %s", action_name)

    def request_action(self, action_name: str, params: Dict[str, Any], actor: Optional[str] = "system") -> RepairAction:
        if action_name not in self.handlers:
            raise RuntimeError("Unknown repair action")
        ra = RepairAction(id=hashlib.sha1((action_name + str(time.time())).encode()).hexdigest(),
                          name=action_name, params=params, timestamp=datetime.now(timezone.utc).isoformat(),
                          actor=actor)
        with self.lock:
            self.action_log.append(ra)
        # Execute synchronously for now (could be queued)
        try:
            ra.status = "EXECUTING"
            ret = self.handlers[action_name](params)
            ra.status = "SUCCESS"
            logger.info("RepairAction success: %s -> %s", ra.name, ret)
        except Exception as e:
            ra.status = "FAILED"
            logger.exception("RepairAction failed: %s", e)
        return ra

# ---------------------------
# Example: tie all together
# ---------------------------
def example_setup():
    # signing key should be HSM backed in prod
    watch = Watchtower(signing_key=b"dev-temp-key-please-use-hsm")
    av = AVHook()
    # preload some indicators (in reality, sync from vendor feeds)
    av.update_from_provider(["203.0.113.15", "baddomain.example", "deadbeefhash"])
    watch.attach_av_hook(av)

    # anomaly detector
    learner = OnlineAnomalyDetector(zscore_threshold=3.5)

    # Register a basic rule: flag CPA entries with source in AV indicators or large numeric anomalies
    def rule_av_and_anomaly(entry: CPAEntry) -> Optional[Dict[str, Any]]:
        payload = entry.payload
        src = payload.get("source", "")
        if watch.av_hook and watch.av_hook.is_indicator(src):
            return {"type": "threat_intel_match", "reason": "Source in AV feed", "source": src, "entry": entry.entry_hash}
        # if payload has numeric metric 'value' we stream to learner
        val = payload.get("metrics", {}).get("value")
        if isinstance(val, (int, float)):
            a = learner.update_stream(float(val))
            if a:
                return {"type": "stat_anomaly", "details": a, "entry": entry.entry_hash}
        return None

    watch.register_rule(rule_av_and_anomaly)

    # register a simple repair agent (quarantine IP & block egress)
    repair = SelfRepairAgent()
    def quarantine_ip_handler(params: Dict[str, Any]) -> Dict[str, Any]:
        ip = params.get("ip")
        if not ip:
            raise RuntimeError("missing ip")
        # placeholder: call firewall API or orchestration system -> here we just log
        logger.info("Quarantine request applied to IP: %s (simulated)", ip)
        return {"quarantined": ip}
    repair.register_handler("quarantine_ip", quarantine_ip_handler)

    # attach alert handler to auto-request remediation for threat_intel_match
    def alert_to_repair(alert: Dict[str, Any]) -> None:
        if alert.get("type") == "threat_intel_match":
            src = alert.get("source")
            # safe default: request quarantine, actor is 'auto-system'
            repair.request_action("quarantine_ip", {"ip": src}, actor="auto-system")

    watch.register_alert_handler(alert_to_repair)

    # ingest several events
    watch.ingest({"type": "network", "source": "192.0.2.1", "metrics": {"value": 1}})
    watch.ingest({"type": "network", "source": "203.0.113.15", "metrics": {"value": 9.0}})
    watch.ingest({"type": "syslog", "source": "192.168.0.5", "metrics": {"value": 6.3}})

    print("Attestation:", watch.attest_root())
    print("Chain length:", len(watch.chain))
    return watch, learner, repair

if __name__ == "__main__":
    example_setup()