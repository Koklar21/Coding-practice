import datetime
import logging
import time
import random
import json
import hashlib
import threading
from typing import Any, Dict, List, Optional, Callable

# --- Initialization and Configuration ---
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s | %(levelname)-8s | %(module)-15s | %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)
SYSTEM_ID = "AEGIS-42-NODE-01"

# ============================================================
#                    OVERSIGHT ENGINE
# ============================================================

class OversightEngine:
    """
    Manages the 'Time-Delayed Veto' workflow.
    Executes actions automatically after a delay unless explicitly vetoed.
    """
    def __init__(self, output_callback: Callable):
        self.pending_actions: Dict[str, threading.Timer] = {}
        self.lock = threading.RLock()
        self.output_callback = output_callback 

    def schedule_action(self, action_id: str, description: str, delay_seconds: int, payload: Callable):
        with self.lock:
            if action_id in self.pending_actions:
                logging.warning(f"[OVERSIGHT] Action {action_id} already pending.")
                return

            logging.info(f"[OVERSIGHT] [PENDING] Action: '{description}'. Executing in {delay_seconds}s unless VETOED.")
            t = threading.Timer(delay_seconds, self._execute_wrapper, args=[action_id, description, payload])
            self.pending_actions[action_id] = t
            t.start()

    def _execute_wrapper(self, action_id: str, description: str, payload: Callable):
        with self.lock:
            if action_id in self.pending_actions:
                logging.info(f"[OVERSIGHT] [TIMEOUT REACHED] Auto-Approving: {description}")
                try:
                    payload()
                    self.output_callback(f"Action '{description}' EXECUTED successfully.")
                except Exception as e:
                    logging.error(f"[OVERSIGHT] Execution failed: {e}")
                finally:
                    if action_id in self.pending_actions:
                        del self.pending_actions[action_id]

    def veto_action(self, action_id: str, user_reason: str):
        with self.lock:
            if action_id in self.pending_actions:
                timer = self.pending_actions[action_id]
                timer.cancel()
                del self.pending_actions[action_id]
                logging.warning(f"[OVERSIGHT] [VETOED] Action: {action_id} aborted by operator. Reason: {user_reason}")
                self.output_callback(f"Action {action_id} was aborted by operator.")
            else:
                logging.warning(f"[OVERSIGHT] Cannot veto {action_id}: Not found or already executed.")

# ============================================================
#                    WATCHTOWER MODULES
# ============================================================

class WatchtowerConfig:
    """Configuration container for a single surveillance module."""
    def __init__(self, name: str, description: str, enabled: bool = True, sensitivity: float = 1.0):
        self.name = name
        self.description = description
        self.enabled = enabled
        self.sensitivity = sensitivity # 0.1 (Lazy) to 2.0 (Paranoid)
        self.last_scan = None

class WatchtowerManager:
    """
    Manages the 8 discrete surveillance modules.
    Naming convention: Standard Enterprise IT (Sterile).
    """
    def __init__(self):
        self.modules: Dict[str, WatchtowerConfig] = {}
        self._initialize_standard_modules()

    def _initialize_standard_modules(self):
        # The "Corporate Sterile" 8
        self.modules["WT_01_RES_MON"] = WatchtowerConfig("WT_01_RES_MON", "System Resource Allocation Monitor")
        self.modules["WT_02_NET_ING"] = WatchtowerConfig("WT_02_NET_ING", "Network Ingress/Egress Traffic Analysis")
        self.modules["WT_03_IAM_AUD"] = WatchtowerConfig("WT_03_IAM_AUD", "Identity Access Management Audit Logger")
        self.modules["WT_04_INT_VER"] = WatchtowerConfig("WT_04_INT_VER", "File System Integrity Verification Service")
        self.modules["WT_05_API_LAT"] = WatchtowerConfig("WT_05_API_LAT", "External API Latency Observer")
        self.modules["WT_06_DB_TXN"]  = WatchtowerConfig("WT_06_DB_TXN",  "Database Transaction Consistency Manager")
        self.modules["WT_07_CNF_MGT"] = WatchtowerConfig("WT_07_CNF_MGT", "Endpoint Configuration Drift Detector")
        self.modules["WT_08_REG_CMP"] = WatchtowerConfig("WT_08_REG_CMP", "Regulatory Compliance Reporting Agent")

    def configure_module(self, module_id: str, enabled: Optional[bool] = None, sensitivity: Optional[float] = None):
        """Updates configuration for a specific watchtower."""
        if module_id in self.modules:
            mod = self.modules[module_id]
            if enabled is not None:
                mod.enabled = enabled
            if sensitivity is not None:
                mod.sensitivity = sensitivity
            logging.info(f"[CONFIG] Updated {module_id}: Enabled={mod.enabled}, Sensitivity={mod.sensitivity}")
        else:
            logging.error(f"[CONFIG] Module {module_id} not found.")

    def perform_scan(self) -> List[str]:
        """Iterates through all enabled modules and simulates scan logic."""
        results = []
        logging.info("[WATCHTOWER] Initiating distributed scan cycle...")
        
        for mid, mod in self.modules.items():
            if not mod.enabled:
                continue

            # Simulation of scan logic based on sensitivity
            mod.last_scan = datetime.datetime.utcnow()
            
            # 10% chance of a finding per scan, scaled by sensitivity
            risk_factor = random.random()
            if risk_factor < (0.1 * mod.sensitivity):
                results.append(f"[{mid}] ANOMALY detected in {mod.description}")
            else:
                # Debug level for "All Clear" to keep main logs clean
                logging.debug(f"[{mid}] Scan complete. Status: Nominal.")
        
        logging.info(f"[WATCHTOWER] Cycle complete. {len(results)} anomalies flagged.")
        return results

# ============================================================
#              SECURITY NODE (UPDATED)
# ============================================================

class SecurityNode:
    def __init__(self):
        self.lock = threading.RLock()
        self.event_log = []
        
        # Initialize Components
        self.oversight = OversightEngine(output_callback=self._log_event)
        self.watchtowers = WatchtowerManager()
        
        self._log_event(f"[{SYSTEM_ID}] Initialization Complete.")
        self._log_event(f"[{SYSTEM_ID}] 8 Watchtower Modules Loaded.")

    def _log_event(self, message: str, module: str = "SYSTEM"):
        with self.lock:
            self.event_log.append((datetime.datetime.utcnow(), message))
            logging.info(f"[{module}] {message}")

    def _execute_quarantine(self, target_ip: str):
        self._log_event(f"*** TARGET {target_ip} ISOLATED VIA FIREWALL RULESET ***", module="DEFENSE_ACT")

    def run_diagnostics(self):
        """Runs the watchtower array."""
        anomalies = self.watchtowers.perform_scan()
        for anomaly in anomalies:
            # If a watchtower finds something, we escalate to the Oversight Engine
            self._log_event(anomaly, module="ALERT")
            
            # Example: If Identity Audit finds something, trigger a block
            if "WT_03_IAM_AUD" in anomaly:
                self.trigger_response("Unknown.User.Identity", "Unauthorized Access Pattern")

    def trigger_response(self, source: str, description: str):
        """Triggers the Veto-able response."""
        action_id = f"BLOCK-{source.replace('.', '-')}-{int(time.time())}"
        
        self.oversight.schedule_action(
            action_id=action_id,
            description=f"Revoke Access for {source}",
            delay_seconds=5,
            payload=lambda: self._execute_quarantine(source)
        )

# ============================================================
#                    SCENARIO SIMULATION
# ============================================================

if __name__ == "__main__":
    node = SecurityNode()

    print("\n--- CONFIGURATION PHASE ---")
    # Configuring the towers
    # We turn up sensitivity on Identity Audit (WT_03) and Network (WT_02)
    node.watchtowers.configure_module("WT_02_NET_ING", sensitivity=1.5)
    node.watchtowers.configure_module("WT_03_IAM_AUD", sensitivity=2.0)
    
    # We disable the "Compliance Reporting" agent because we don't care about paper pushing right now
    node.watchtowers.configure_module("WT_08_REG_CMP", enabled=False)

    print("\n--- OPERATIONAL PHASE ---")
    # Run a few scan cycles
    for i in range(3):
        print(f"\n[Cycle {i+1}] Running Diagnostics...")
        node.run_diagnostics()
        time.sleep(1)

    print("\n--- PENDING ACTIONS CHECK ---")
    # If the random chance triggered an anomaly in WT_03, we should see a pending action here.
    with node.oversight.lock:
        pending_count = len(node.oversight.pending_actions)
        print(f"Pending Actions in Queue: {pending_count}")
        if pending_count > 0:
            print(">> System is waiting for Operator Veto...")
            time.sleep(6) # Let it execute

    print("\n--- END LOG ---")