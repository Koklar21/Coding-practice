import platform
import subprocess
import datetime
import random
import sys
import hmac
import hashlib
import json
import logging
import shutil
import time
from typing import Dict, Any, List, Optional, Protocol
from dataclasses import dataclass, asdict

# ---------- Setup logging ----------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s %(levelname)s retail_node %(message)s",
)
log = logging.getLogger("retail_node")

# ---------- Simple inventory provider hook ----------
class InventoryProvider(Protocol):
    def current_stock(self, sku: str) -> int: ...

class RandomInventory(InventoryProvider):
    def current_stock(self, sku: str) -> int:
        return random.randint(50, 150)

# ---------- Transaction model with basic validation ----------
@dataclass(frozen=True)
class Transaction:
    id: str
    sku: str
    qty: int
    amount: float

    def validate(self) -> None:
        if not self.id or not self.sku:
            raise ValueError("Transaction id and sku are required")
        if self.qty <= 0:
            raise ValueError("qty must be > 0")
        if self.amount < 0:
            raise ValueError("amount must be >= 0")

class RetailNode:
    """
    Project Yggdrasil: Upgraded Retail Node (V2.1)
    - Structured logging
    - HMAC-backed witness signing
    - Runtime probing with which()
    - Bounded, persistent offline cache
    - Basic schema validation
    """
    HMAC_SECRET = b"witness-mesh-secret"  # replace via env/keystore in prod
    OFFLINE_CACHE_PATH = "offline_cache.jsonl"
    OFFLINE_CACHE_MAX = 10_000  # guardrail

    def __init__(self, inventory_provider: Optional[InventoryProvider] = None):
        self.compliance_status: bool = True
        self.os_name: str = self.detect_os()
        self.runtimes: Dict[str, Any] = self.detect_runtimes()
        self.inventory: InventoryProvider = inventory_provider or RandomInventory()

        self.pos_logs: List[Dict[str, Any]] = []
        self.sales_data: List[Dict[str, Any]] = []
        self.reorder_flags: List[Dict[str, Any]] = []
        self.offline_cache: List[Dict[str, Any]] = []
        self._load_offline_cache()

    # ---------- CPA / Witness ----------
    def log_to_cpa_chain(self, message: str, **fields):
        payload = {"msg": message, **fields}
        log.info("[CPA] %s", json.dumps(payload, separators=(",", ":")))

    def witness_mesh_sign(self, message: str, **fields):
        payload = {"msg": message, **fields}
        digest = hmac.new(self.HMAC_SECRET, json.dumps(payload, sort_keys=True).encode(), hashlib.sha256).hexdigest()
        log.info("[WITNESS] %s", json.dumps({"payload": payload, "sig": digest}, separators=(",", ":")))

    # ---------- Runtime / OS ----------
    def detect_os(self) -> str:
        os_name = platform.system()
        self.log_to_cpa_chain("Retail Node OS detected", os=os_name)
        self.witness_mesh_sign("OS Detection Signed", os=os_name)
        return os_name

    def _safe_run(self, command: List[str]) -> Optional[str]:
        exe = command[0]
        if shutil.which(exe) is None:
            return None
        try:
            result = subprocess.run(command, capture_output=True, text=True, timeout=3, check=False)
            out = (result.stdout or result.stderr or "").strip()
            return out.splitlines()[0] if out else f"Found (Exit Code {result.returncode})"
        except Exception as e:
            self.log_to_cpa_chain("Runtime probe error", command=command, error=str(e))
            return None

    def detect_runtimes(self) -> Dict[str, Any]:
        runtimes = {
            "Python": sys.version.split("\n")[0],
            "Node.js": self._safe_run(["node", "--version"]),
            "Java": self._safe_run(["java", "-version"]),  # stderr handled
            "Go": self._safe_run(["go", "version"]),
            "Ruby": self._safe_run(["ruby", "--version"]),
        }
        if self.os_name == "Windows":
            ps = self._safe_run(["powershell", "-NoProfile", "-Command", "$PSVersionTable.PSVersion.ToString()"])
            if ps: runtimes["PowerShell"] = ps
        active = {k: v for k, v in runtimes.items() if v}
        self.log_to_cpa_chain("Retail runtimes detected", runtimes=active)
        self.witness_mesh_sign("Runtime Detection Signed", count=len(active))
        return active

    # ---------- Compliance ----------
    def verify_compliance(self):
        if not self.compliance_status:
            self.log_to_cpa_chain("Retail Compliance Violation! Node Locked.")
            self.witness_mesh_sign("Compliance Lockdown Signed")
            self.lock_node()
        else:
            self.log_to_cpa_chain("Retail Compliance Verified")
            self.witness_mesh_sign("Compliance OK Signed")

    def lock_node(self):
        self.log_to_cpa_chain("Retail Node Disabled Due to Compliance Breach")
        self.witness_mesh_sign("Node Lockdown Signed")
        # Future: raise a custom exception to stop flows programmatically

    def _ensure_unlocked(self):
        if not self.compliance_status:
            raise PermissionError("Retail node is locked due to compliance failure")

    # ---------- POS ----------
    def record_pos_sale(self, transaction: Dict[str, Any]):
        self._ensure_unlocked()
        tx = Transaction(**transaction)
        tx.validate()

        self.sales_data.append(asdict(tx))
        entry = {"timestamp": datetime.datetime.utcnow().isoformat(), "transaction": asdict(tx)}
        self.pos_logs.append(entry)

        self.log_to_cpa_chain("POS Sale Recorded", sku=tx.sku, qty=tx.qty, amount=tx.amount)
        self.witness_mesh_sign("POS Sale Signed", id=tx.id, sku=tx.sku)

    def daily_sales_sync(self):
        self._ensure_unlocked()
        count = len(self.sales_data)
        self.log_to_cpa_chain("Daily Sales Sync started", count=count)
        self.witness_mesh_sign("Daily Sync Signed", count=count)
        self.sales_data.clear()

    # ---------- Reorder ----------
    def check_reorder_trigger(self, predictive_demand: int, sku: str = "DEFAULT-SKU"):
        self._ensure_unlocked()
        stock_level = self.inventory.current_stock(sku)
        self.log_to_cpa_chain("Stock vs Demand", stock=stock_level, demand=predictive_demand, sku=sku)

        if stock_level < predictive_demand:
            reorder_qty = predictive_demand - stock_level
            flag = {"timestamp": datetime.datetime.utcnow().isoformat(), "needed": reorder_qty, "sku": sku}
            self.reorder_flags.append(flag)
            self.log_to_cpa_chain("Reorder Triggered", sku=sku, qty=reorder_qty)
            self.witness_mesh_sign("Reorder Flag Signed", sku=sku, qty=reorder_qty)

    # ---------- Offline cache (persisted) ----------
    def _load_offline_cache(self):
        try:
            with open(self.OFFLINE_CACHE_PATH, "r", encoding="utf-8") as f:
                for line in f:
                    self.offline_cache.append(json.loads(line))
            self.log_to_cpa_chain("Offline cache loaded", count=len(self.offline_cache))
        except FileNotFoundError:
            pass

    def _append_offline_file(self, tx: Dict[str, Any]):
        with open(self.OFFLINE_CACHE_PATH, "a", encoding="utf-8") as f:
            f.write(json.dumps(tx, separators=(",", ":")) + "\n")

    def offline_cache_transaction(self, transaction: Dict[str, Any]):
        tx = Transaction(**transaction)
        tx.validate()
        if len(self.offline_cache) >= self.OFFLINE_CACHE_MAX:
            self.log_to_cpa_chain("Offline cache full, dropping oldest")
            self.offline_cache.pop(0)
        self.offline_cache.append(asdict(tx))
        self._append_offline_file(asdict(tx))
        self.log_to_cpa_chain("Transaction Cached Offline", sku=tx.sku, id=tx.id)

    def push_offline_cache(self, max_retries: int = 3):
        if not self.offline_cache:
            self.log_to_cpa_chain("No Offline Cache to Push.")
            return

        attempt = 0
        while attempt < max_retries:
            try:
                count = len(self.offline_cache)
                self.sales_data.extend(self.offline_cache)
                self.log_to_cpa_chain("Pushing Offline Transactions", count=count)
                self.offline_cache.clear()

                # truncate file
                open(self.OFFLINE_CACHE_PATH, "w").close()
                self.daily_sales_sync()
                return
            except Exception as e:
                attempt += 1
                wait = 2 ** attempt
                self.log_to_cpa_chain("Offline push failed, retrying", attempt=attempt, wait_s=wait, error=str(e))
                time.sleep(wait)
        self.log_to_cpa_chain("Offline push aborted after retries")

if __name__ == "__main__":
    print("--- Initializing Project Yggdrasil Retail Node V2.1 ---")
    random.seed(42)  # remove in prod; keeps demos deterministic
    retail = RetailNode()
    print("-" * 40)
    print(f"Detected Runtimes: {retail.runtimes}")
    print(f"OS Name: {retail.os_name}")
    print("-" * 40)

    retail.record_pos_sale({"id": "T001", "sku": "ABC123", "qty": 2, "amount": 40.00})
    retail.check_reorder_trigger(predictive_demand=120, sku="ABC123")
    retail.verify_compliance()

    print("\n--- SIMULATING OFFLINE CACHE AND PUSH ---")
    retail.offline_cache_transaction({"id": "T002", "sku": "XYZ789", "qty": 1, "amount": 15.00})
    retail.offline_cache_transaction({"id": "T003", "sku": "DEF456", "qty": 5, "amount": 25.50})
    retail.push_offline_cache()

    print("\n--- SIMULATING COMPLIANCE FAILURE ---")
    retail.compliance_status = False
    try:
        retail.verify_compliance()
        retail.record_pos_sale({"id": "T004", "sku": "LOCKED", "qty": 1, "amount": 1.00})  # will raise
    except PermissionError as e:
        log.warning("Blocked while locked: %s", e)
    print("-" * 40)
    print("DEMO ENDED.")