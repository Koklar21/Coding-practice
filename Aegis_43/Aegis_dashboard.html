<script>
  const logConsole = document.getElementById("log-console");
  const threatFeed = document.getElementById("threat-feed");
  const recordCountEl = document.getElementById("record-count");

  // In-memory state
  const threats = new Map();

  // -----------------------------
  // Backend seam (wire later)
  // -----------------------------
  const api = {
    log: async (level, module, message, context = null) => {
      // TODO: POST /api/v1/logs
      // await fetch("/api/v1/logs", {method:"POST", headers:{...}, body: JSON.stringify({level,module,message,context})})
      return true;
    },
    veto: async (actionId, operatorId, reason) => {
      // TODO: POST /api/v1/oversight/veto
      return true;
    },
    execute: async (actionId) => {
      // TODO: POST /api/v1/oversight/execute
      return true;
    },
    vaultStats: async () => {
      // TODO: GET /api/v1/vault/stats
      return { records: null };
    },
  };

  function nowStamp() {
    return new Date().toISOString().split("T")[1].split(".")[0];
  }

  function addLog(msg, type = "info") {
    const div = document.createElement("div");
    div.className = `log-entry ${type}`;
    div.textContent = `[${nowStamp()}] ${msg}`;
    logConsole.appendChild(div);
    logConsole.scrollTop = logConsole.scrollHeight;
  }

  function fmtMMSS(seconds) {
    const s = Math.max(0, seconds | 0);
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  function uid() {
    // stable-ish unique ID without collisions
    return `ACT-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`.toUpperCase();
  }

  // -----------------------------
  // Telemetry spam (demo mode)
  // -----------------------------
  setInterval(() => {
    const msgs = [
      "[WATCHTOWER] Heartbeat check nominal.",
      "[DB_TXN] Transaction committed.",
      "[API_LAT] Latency < 12ms.",
      "[IAM_AUD] Session validation pass.",
      "[RES_MON] CPU steady < 42%.",
      "[INT_VER] File integrity baseline unchanged."
    ];
    addLog(msgs[Math.floor(Math.random() * msgs.length)], "info");
  }, 2000);

  // -----------------------------
  // Core UI: create + manage threats
  // -----------------------------
  function createThreat(ip, threatType, delaySeconds = 30) {
    const id = uid();
    const createdAt = Date.now();
    const executeAt = createdAt + delaySeconds * 1000;

    const card = document.createElement("div");
    card.className = "threat-card";
    card.id = id;

    card.innerHTML = `
      <div class="threat-info">
        <h3>DETECTED: ${escapeHtml(threatType)}</h3>
        <p>Source: ${escapeHtml(ip)} | Action: FIREWALL BLOCK</p>
        <p style="margin-top:6px;">Action ID: <span style="color:#cbd5e1">${id}</span></p>
      </div>
      <div style="display:flex; align-items:center;">
        <div class="countdown-timer" id="timer-${id}">${fmtMMSS(delaySeconds)}</div>
        <button class="veto-btn" onclick="vetoAction('${id}')">ABORT ACTION</button>
      </div>
    `;
    threatFeed.appendChild(card);

    const ctx = { action_id: id, ip, threat_type: threatType, delay_seconds: delaySeconds };
    addLog(`[THREAT_INT] High confidence threat detected: ${threatType} from ${ip}`, "crit");
    addLog(`[OVERSIGHT] Action staged: ${id}. Executes in ${delaySeconds}s unless vetoed.`, "warn");
    api.log("INFO", "THREAT_INT", "Threat detected", ctx);
    api.log("INFO", "OVERSIGHT", "Action staged", ctx);

    const state = {
      id,
      ip,
      threatType,
      createdAt,
      executeAt,
      active: true,
      interval: null,
      card,
    };

    state.interval = setInterval(() => tickThreat(id), 250);
    threats.set(id, state);
  }

  function tickThreat(actionId) {
    const t = threats.get(actionId);
    if (!t || !t.active) return;

    const remainingMs = t.executeAt - Date.now();
    const remainingSec = Math.ceil(remainingMs / 1000);

    const timerEl = document.getElementById(`timer-${actionId}`);
    if (timerEl) timerEl.textContent = fmtMMSS(remainingSec);

    if (remainingSec <= 0) {
      executeAction(actionId);
    }
  }

  async function vetoAction(actionId) {
    const t = threats.get(actionId);
    if (!t || !t.active) return;

    const operatorId = prompt("Operator ID:", "operator01");
    if (operatorId === null) return;

    const reason = prompt("Veto reason (required):", "Authorized traffic / false positive");
    if (reason === null || reason.trim() === "") {
      addLog(`[OVERSIGHT] VETO aborted: reason required for ${actionId}.`, "warn");
      return;
    }

    // stop countdown
    t.active = false;
    clearInterval(t.interval);

    // update card
    const targetCard = document.getElementById(actionId);
    if (targetCard) {
      targetCard.className = "threat-card vetoed-card";
      targetCard.innerHTML = `
        <div class="threat-info">
          <h3 style="color:#9ca3af">ACTION ABORTED</h3>
          <p>Operator Override Applied.</p>
          <p style="margin-top:6px;">Operator: <span style="color:#cbd5e1">${escapeHtml(operatorId)}</span></p>
          <p>Reason: <span style="color:#cbd5e1">${escapeHtml(reason)}</span></p>
          <p>Action ID: <span style="color:#cbd5e1">${actionId}</span></p>
        </div>
        <div style="color: var(--text-secondary); font-weight:bold;">VETOED</div>
      `;
    }

    addLog(`[OVERSIGHT] Action ${actionId} VETOED by ${operatorId}. Reason: ${reason}`, "warn");
    api.log("INFO", "OVERSIGHT", "Action vetoed", { action_id: actionId, operator_id: operatorId, reason });

    await api.veto(actionId, operatorId, reason);
    threats.delete(actionId);
  }

  window.vetoAction = vetoAction;

  async function executeAction(actionId) {
    const t = threats.get(actionId);
    if (!t || !t.active) return;

    t.active = false;
    clearInterval(t.interval);

    // remove card
    if (t.card && t.card.parentNode) t.card.parentNode.removeChild(t.card);

    addLog(`[AUTOMATION] TIMEOUT REACHED. Executing block for ${t.ip} (Action ${actionId})...`, "crit");
    addLog(`[FIREWALL] Rule AEGIS_BLOCK created for ${t.ip}. Success.`, "info");

    api.log("INFO", "OVERSIGHT", "Action auto-executed", { action_id: actionId, ip: t.ip, threat_type: t.threatType });
    await api.execute(actionId);

    threats.delete(actionId);
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  // Optional: update vault record count (when backend exists)
  async function refreshVaultStats() {
    const stats = await api.vaultStats();
    if (stats && typeof stats.records === "number") {
      recordCountEl.textContent = stats.records.toLocaleString();
    }
  }
  setInterval(refreshVaultStats, 10000);

  // Demo injections
  setTimeout(() => createThreat("203.0.113.45", "SQL INJECTION PATTERN", 30), 3000);
  setTimeout(() => createThreat("198.51.100.12", "DATA EXFILTRATION", 45), 15000);
</script>