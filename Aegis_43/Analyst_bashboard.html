<script>
  // ------------------------------------------------------------
  // Modes (display only; backend is authority)
  // ------------------------------------------------------------
  const MODES = {
    SHADOW: "SHADOW",
    ACTIVE: "ACTIVE",
    HUMAN_GATED: "HUMAN_GATED"
  };

  const feed = document.getElementById("incident-feed");
  const consoleLog = document.getElementById("log-console");
  const modeBadge = document.getElementById("system-mode");
  const toggleBtn = document.getElementById("toggle-mode");
  const injectBtn = document.getElementById("inject-test");
  const queueCount = document.getElementById("queue-count");
  const statusPill = document.getElementById("status-pill");

  // Gate demo behavior
  const DEMO_MODE = (window.AEGIS_DEMO_MODE ?? true) === true;

  // Render cache: action_id -> last snapshot
  const incidents = new Map();

  // ------------------------------------------------------------
  // Backend seam (wire later)
  // ------------------------------------------------------------
  const api = {
    token: () => sessionStorage.getItem("AEGIS_JWT") || null,
    headers: () => {
      const h = { "Content-Type": "application/json" };
      const t = api.token();
      if (t) h["Authorization"] = `Bearer ${t}`;
      return h;
    },

    // Source of truth: server incident queue
    listIncidents: async () => {
      if (DEMO_MODE) return demo.listIncidents();
      const r = await fetch("/api/v1/incidents", { headers: api.headers() });
      if (!r.ok) throw new Error("Failed to fetch incidents");
      return r.json(); // {mode, status, incidents:[...]}
    },

    // Mode set is a request; server decides final mode
    setMode: async (mode) => {
      if (DEMO_MODE) return demo.setMode(mode);
      const r = await fetch("/api/v1/mode", {
        method: "POST",
        headers: api.headers(),
        body: JSON.stringify({ mode }),
      });
      if (!r.ok) throw new Error("Failed to set mode");
      return r.json();
    },

    veto: async (actionId, reason) => {
      if (DEMO_MODE) return demo.veto(actionId, reason);
      const r = await fetch("/api/v1/oversight/veto", {
        method: "POST",
        headers: api.headers(),
        body: JSON.stringify({ action_id: actionId, reason }),
      });
      return r.ok;
    },

    approve: async (actionId) => {
      if (DEMO_MODE) return demo.approve(actionId);
      const r = await fetch("/api/v1/oversight/approve", {
        method: "POST",
        headers: api.headers(),
        body: JSON.stringify({ action_id: actionId }),
      });
      return r.ok;
    },

    // Demo-only: inject test event (server should own this too)
    inject: async () => {
      if (DEMO_MODE) return demo.inject();
      const r = await fetch("/api/v1/incidents/inject", { method: "POST", headers: api.headers() });
      return r.ok;
    }
  };

  // ------------------------------------------------------------
  // Demo provider (server-ish behavior)
  // ------------------------------------------------------------
  const demo = (() => {
    let mode = MODES.SHADOW;
    const state = new Map(); // action_id -> inc

    function id() {
      return `ACT-${Date.now().toString(36)}-${Math.random().toString(36).slice(2, 8)}`.toUpperCase();
    }

    function nowMs() { return Date.now(); }

    function add(ip, threat, delaySeconds) {
      const created = nowMs();
      const action_id = id();
      state.set(action_id, {
        action_id,
        ip,
        threat,
        created_at_ms: created,
        execute_at_ms: created + delaySeconds * 1000,
        status: (mode === MODES.HUMAN_GATED) ? "STAGED" : (mode === MODES.SHADOW ? "SHADOWED" : "PENDING"),
        veto_reason: ""
      });
    }

    function listIncidents() {
      const now = nowMs();

      // backend truth: in ACTIVE, auto-exec when time hits
      if (mode === MODES.ACTIVE) {
        for (const inc of state.values()) {
          if (inc.status === "PENDING" && now >= inc.execute_at_ms) {
            inc.status = "EXECUTED";
          }
        }
      }

      return {
        mode,
        status: "Online",
        incidents: Array.from(state.values()).sort((a,b) => b.created_at_ms - a.created_at_ms)
      };
    }

    function setMode(newMode) {
      mode = newMode;
      // adjust newly created incident behavior only; keep old as-is
      return { mode };
    }

    function veto(actionId, reason) {
      const inc = state.get(actionId);
      if (!inc) return false;
      if (inc.status !== "PENDING" && inc.status !== "STAGED") return false;
      inc.status = "VETOED";
      inc.veto_reason = reason;
      return true;
    }

    function approve(actionId) {
      const inc = state.get(actionId);
      if (!inc) return false;
      if (inc.status !== "STAGED") return false;
      inc.status = "APPROVED";
      // backend would execute, then mark executed
      setTimeout(() => { inc.status = "EXECUTED"; }, 250);
      return true;
    }

    function inject() {
      const ips = ["203.0.113.88", "198.51.100.22", "192.0.2.44", "10.1.2.3"];
      const threats = ["SQL Injection", "RDP Brute Force", "Credential Stuffing", "Anomalous API Burst"];
      add(ips[Math.floor(Math.random() * ips.length)], threats[Math.floor(Math.random() * threats.length)], 15);
      return true;
    }

    // preload
    add("203.0.113.88", "SQL Injection Attempt", 15);
    add("198.51.100.22", "RDP Brute Force", 20);

    return { listIncidents, setMode, veto, approve, inject };
  })();

  // ------------------------------------------------------------
  // UI helpers
  // ------------------------------------------------------------
  function addLog(msg, type = "") {
    const div = document.createElement("div");
    div.className = `log-line ${type}`;
    div.textContent = msg.startsWith("[") ? msg : `> ${msg}`;
    consoleLog.appendChild(div);
    consoleLog.scrollTop = consoleLog.scrollHeight;
  }

  function formatSeconds(sec) {
    const s = Math.max(0, sec | 0);
    const mm = String(Math.floor(s / 60)).padStart(2, "0");
    const ss = String(s % 60).padStart(2, "0");
    return `${mm}:${ss}`;
  }

  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function setModeBadge(mode) {
    if (mode === MODES.SHADOW) {
      modeBadge.textContent = "MODE: SHADOW ADVISORY (SIMULATION)";
      modeBadge.style.background = "#fef3c7";
      modeBadge.style.borderColor = "#fcd34d";
      modeBadge.style.color = "#b45309";
    } else if (mode === MODES.ACTIVE) {
      modeBadge.textContent = "MODE: ACTIVE DEFENSE (VETO WINDOW)";
      modeBadge.style.background = "#fee2e2";
      modeBadge.style.borderColor = "#fca5a5";
      modeBadge.style.color = "#b91c1c";
    } else {
      modeBadge.textContent = "MODE: HUMAN GATED (APPROVAL REQUIRED)";
      modeBadge.style.background = "#e0f2fe";
      modeBadge.style.borderColor = "#7dd3fc";
      modeBadge.style.color = "#075985";
    }
  }

  function updateQueueCount(items) {
    const count = items.filter(x => x.status === "PENDING" || x.status === "STAGED").length;
    queueCount.textContent = String(count);
  }

  function rowTag(inc) {
    if (inc.status === "SHADOWED") return { cls:"shadow", label:"SHADOW" };
    if (inc.status === "STAGED") return { cls:"gated", label:"GATED" };
    if (inc.status === "PENDING") return { cls:"active", label:"ACTIVE" };
    return { cls:"shadow", label: inc.status };
  }

  function renderIncidentRow(inc, currentMode) {
    const row = document.createElement("div");
    row.className = "incident-row";
    row.dataset.actionId = inc.action_id;

    const tag = rowTag(inc);
    const created = new Date(inc.created_at_ms).toLocaleString();

    const actionArea = document.createElement("div");
    actionArea.className = "action-area";

    // Timer is display-only: server controls execution
    if (inc.status === "PENDING" && currentMode === MODES.ACTIVE) {
      const timerEl = document.createElement("span");
      timerEl.className = "timer";
      timerEl.dataset.timerFor = inc.action_id;
      timerEl.textContent = "--:--";
      actionArea.appendChild(timerEl);

      const vetoBtn = document.createElement("button");
      vetoBtn.className = "btn-veto";
      vetoBtn.textContent = "VETO";
      vetoBtn.dataset.veto = inc.action_id;
      actionArea.appendChild(vetoBtn);
    } else if (inc.status === "STAGED" && currentMode === MODES.HUMAN_GATED) {
      const approveBtn = document.createElement("button");
      approveBtn.className = "btn-approve";
      approveBtn.textContent = "APPROVE";
      approveBtn.dataset.approve = inc.action_id;

      const vetoBtn = document.createElement("button");
      vetoBtn.className = "btn-veto";
      vetoBtn.textContent = "VETO";
      vetoBtn.dataset.veto = inc.action_id;

      actionArea.appendChild(approveBtn);
      actionArea.appendChild(vetoBtn);
    } else {
      const note = document.createElement("div");
      note.style.fontSize = "12px";
      note.style.fontWeight = "800";
      note.style.color = "#6b7280";
      note.textContent = inc.status;
      actionArea.appendChild(note);
    }

    row.innerHTML = `
      <div class="incident-details">
        <h4>Threat: ${escapeHtml(inc.threat)} <span class="tag ${tag.cls}">${tag.label}</span></h4>
        <p>Source: ${escapeHtml(inc.ip)} | Created: ${escapeHtml(created)}</p>
        <p style="margin-top:6px;">Action ID: <span style="color:#374151">${escapeHtml(inc.action_id)}</span></p>
        ${inc.veto_reason ? `<p><strong>Veto:</strong> ${escapeHtml(inc.veto_reason)}</p>` : ""}
      </div>
    `;
    row.appendChild(actionArea);
    return row;
  }

  function rerender(items, mode) {
    feed.innerHTML = "";
    for (const inc of items) {
      feed.appendChild(renderIncidentRow(inc, mode));
    }
    updateQueueCount(items);
  }

  function updateTimers(items) {
    const now = Date.now();
    for (const inc of items) {
      if (!inc.execute_at_ms) continue;
      const el = feed.querySelector(`[data-timer-for="${inc.action_id}"]`);
      if (!el) continue;
      const remaining = Math.ceil((inc.execute_at_ms - now) / 1000);
      el.textContent = formatSeconds(remaining);
    }
  }

  // ------------------------------------------------------------
  // Actions (event delegation)
  // ------------------------------------------------------------
  feed.addEventListener("click", async (e) => {
    const vetoBtn = e.target.closest("[data-veto]");
    const approveBtn = e.target.closest("[data-approve]");

    if (vetoBtn) {
      const id = vetoBtn.dataset.veto;
      const reason = (prompt("Veto reason (required):", "Authorized traffic / false positive") || "").trim();
      if (!reason) {
        addLog(`[OVERSIGHT] VETO aborted: reason required for ${id}.`, "sim");
        return;
      }
      const ok = await api.veto(id, reason);
      addLog(ok ? `[OVERSIGHT] VETOED ${id} | Reason: ${reason}` : `[OVERSIGHT] VETO FAILED ${id}`, ok ? "ok" : "crit");
      return;
    }

    if (approveBtn) {
      const id = approveBtn.dataset.approve;
      const ok = await api.approve(id);
      addLog(ok ? `[OVERSIGHT] APPROVED ${id}` : `[OVERSIGHT] APPROVE FAILED ${id}`, ok ? "crit" : "crit");
      return;
    }
  });

  toggleBtn.addEventListener("click", async () => {
    // Rotate SHADOW <-> ACTIVE for now; keep HUMAN_GATED for later
    const next = (modeBadge.textContent.includes("SHADOW")) ? MODES.ACTIVE : MODES.SHADOW;
    try {
      const res = await api.setMode(next);
      addLog(`[CFG] Mode set requested: ${next}`, next === MODES.ACTIVE ? "crit" : "sim");
      if (res && res.mode) setModeBadge(res.mode);
    } catch (err) {
      addLog(`[CFG] Mode switch failed: ${String(err)}`, "crit");
    }
  });

  injectBtn.addEventListener("click", async () => {
    const ok = await api.inject();
    addLog(ok ? "[TEST] Injected test incident." : "[TEST] Inject failed.", ok ? "ok" : "crit");
  });

  // ------------------------------------------------------------
  // Poll loop (server truth)
  // ------------------------------------------------------------
  async function refresh() {
    try {
      const payload = await api.listIncidents();
      const mode = payload.mode || MODES.SHADOW;
      const status = payload.status || "Online";
      const items = payload.incidents || [];

      statusPill.textContent = status;
      setModeBadge(mode);

      rerender(items, mode);
      updateTimers(items);
    } catch (err) {
      statusPill.textContent = "Degraded";
      addLog(`[UI] Refresh failed: ${String(err)}`, "crit");
    }
  }

  // Boot
  addLog("[SYS] Analyst Workstation Loaded.", "ok");
  addLog(DEMO_MODE ? "[CFG] DEMO MODE enabled." : "[CFG] Live mode enabled.", "sim");
  setInterval(refresh, 800);
  refresh();
</script>